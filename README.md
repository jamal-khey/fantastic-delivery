

## Backend:

the project expose api for booking a slot for delivery, you can see the full list of endpoint at:
http://127.0.0.1:8080/swagger-ui/index.html

at the startup the application create some delivery slots (for testing purposes), which can be generated by a cron job
in a real production system for example each day at 00:00

in this project i pre-populate the database with some test data

> Note: I didn't had the time to handle race-conditions on the booking of the slots
if two user try to book a slot in the same time , the last one will override the slot
we should implement some kind of locking , (this may affect the scalability of the system)

> Note: i am using jpa as a ORM with h2, in a real system i would probably use postgres
with liquibase

> Note: we may also publish the booked delivery slots using a message queue like Kafka or rabbitMQ
to allow others part of the system to subscribe to the events

to run the backend 

- cd ecommerce 
- mvn clean package
- mvn spring-boot:run


## Front end

i generated a nextjs projet with tailwind
i use chad-cn, a popular component library

the ui is mostly server side rendered

the user can select if he want a delivery at home or drive. 
then he can choose one of the available slots

to run the project
- npm install
- npm run dev

> note: if npm install does not work , try "rm package-lock.json && npm install"


## Deployment

to deploy the project i would create an image for the spring boot by using [jib](https://github.com/GoogleContainerTools/jib/blob/master/jib-maven-plugin/README.md#configuration)

for the frontend i created a dockerfile to build the image to build the image 'docker build .'

for testing on local machine it is possible to use docker compose with the images
but for production env a popular solution right now is to use kubernetes

if i wanted to deploy this project as it is on kubernetes i will need
- 1 deployment for the database https://artifacthub.io/packages/helm/bitnami/postgresql
- create 1 deployment for the springboot project
- create 1 deployment for the frontend
- 1 Ingress to expose the front end to the external world
- 1 ingress to expose the springboot app to the external world


## CI/CD
if we use github/gitlab we can define workflow to build / run unit test on each commit on a pull request before allowing
the developer to merge the pull request.(we may also require at least one review)

one the pull request merged on main, another workflow can build and push the docker images

## Testing
on top of unit tests we can implement e2e testing with cypress (my favorite solution due to it's simplicity)

